<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Python Graphics Learning</title>

    <!-- CodeMirror 6 styles are included in the library -->

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Left panel - instructions */
        .instructions {
            width: 350px;
            background: #f5f5f5;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #ddd;
        }

        .instructions h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .instructions h3 {
            color: #555;
            margin: 15px 0 10px 0;
            font-size: 16px;
        }

        .instructions code {
            background: #fff;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
        }

        .instructions ul {
            margin-left: 20px;
            line-height: 1.6;
        }

        .instructions li {
            margin: 8px 0;
        }

        .hint {
            background: #fff3cd;
            padding: 10px;
            border-left: 4px solid #ffc107;
            margin: 10px 0;
            border-radius: 4px;
        }

        /* Right panel - editor + canvas */
        .workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: #2d2d2d;
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .toolbar button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .toolbar button:hover {
            background: #45a049;
        }

        .toolbar button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .editor-container {
            flex: 1;
            position: relative;
            background: #282a36;
        }

        .editor-container .cm-editor {
            height: 100%;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 14px;
        }

        .editor-container .cm-scroller {
            overflow: auto;
        }

        #editor {
            display: none;
        }

        .canvas-container {
            height: 400px;
            background: white;
            border-top: 2px solid #ddd;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .canvas-container svg {
            max-width: 100%;
            height: auto;
        }

        .error {
            background: #f44336;
            color: white;
            padding: 10px 20px;
            display: none;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 16px;
        }
    </style>
</head>

<body>
    <div class="instructions">
        <h2>üå∏ Project 1: Draw Your First Flower</h2>

        <h3>Goal:</h3>
        <p>Draw a simple stylized flower using circles and ellipses.</p>

        <h3>What you'll learn:</h3>
        <ul>
            <li>Creating a canvas</li>
            <li>Drawing circles and ellipses</li>
            <li>Using the CreativeGardenPalette</li>
            <li>Positioning shapes with coordinates</li>
        </ul>

        <div class="hint">
            <strong>‚ú® Autocomplete:</strong> Type <code>can.</code> to see all Canvas methods!
            Press <strong>Tab</strong> or <strong>Enter</strong> to accept, then <strong>Tab</strong> through placeholders. <code>Ctrl+Space</code> for manual suggestions.
        </div>

        <h3>Steps:</h3>
        <ol>
            <li>Create a canvas: <code>can = Canvas(800, 600)</code></li>
            <li>Draw petals using circles or ellipses</li>
            <li>Add a center circle for the flower</li>
            <li>Draw a stem and leaves</li>
        </ol>

        <div class="hint">
            <strong>üí° Hint:</strong> The canvas coordinates start at the top-left (0, 0).
            X increases to the right, Y increases downward.
        </div>

        <h3>Available Methods:</h3>
        <ul>
            <li><code>can.circle(x, y, radius, fill=...)</code></li>
            <li><code>can.ellipse(x, y, rx, ry, fill=...)</code></li>
            <li><code>can.rect(x, y, width, height, fill=...)</code></li>
            <li><code>can.line(x1, y1, x2, y2, stroke=...)</code></li>
            <li><code>can.grid(spacing=50)</code> - Show coordinate grid</li>
            <li><code>can.show_palette(PaletteClass)</code> - Display palette colors</li>
        </ul>

        <h3>Creative Garden Palette:</h3>
        <p><code>CreativeGardenPalette.ROSE_QUARTZ</code>, <code>BUTTER_YELLOW</code>, <code>MINT_CREAM</code>,
            <code>SKY_BREEZE</code>, <code>LILAC_DREAM</code>, <code>CORAL_BLUSH</code>
        </p>

        <div class="hint">
            <strong>üí° Tip:</strong> Try <code>can.show_palette(CreativeGardenPalette)</code> to see all available colors!
            Also available: <code>CalmOasisPalette</code> and <code>Color</code> (basic colors).
        </div>

        <div class="hint">
            <strong>üé® Challenge:</strong> Can you add more petals or change colors?
            Try experimenting with different positions and sizes!
        </div>
    </div>

    <div class="workspace">
        <div class="toolbar">
            <button id="runBtn" onclick="runCode()">‚ñ∂ Run Code</button>
            <button onclick="clearCanvas()">üóëÔ∏è Clear</button>
            <span id="status" style="color: #aaa; margin-left: 10px;"></span>
        </div>

        <div class="error" id="error"></div>

        <div class="editor-container">
            <textarea id="editor" spellcheck="false"># Draw your flower here!

can = Canvas(800, 600)

# Draw a coordinate grid to help with positioning
can.grid(spacing=50, show_coords=True)

# Flower center position
cx, cy = 400, 250

# Draw 5 petals around the center (like a simple flower)
petal_radius = 50
can.circle(cx, cy - 60, petal_radius, fill=CreativeGardenPalette.ROSE_QUARTZ)  # Top
can.circle(cx + 50, cy - 30, petal_radius, fill=CreativeGardenPalette.CORAL_BLUSH)  # Top right
can.circle(cx + 50, cy + 30, petal_radius, fill=CreativeGardenPalette.LILAC_DREAM)  # Bottom right
can.circle(cx - 50, cy + 30, petal_radius, fill=CreativeGardenPalette.SKY_BREEZE)  # Bottom left
can.circle(cx - 50, cy - 30, petal_radius, fill=CreativeGardenPalette.PEACH_WHISPER)  # Top left

# Flower center
can.circle(cx, cy, 35, fill=CreativeGardenPalette.BUTTER_YELLOW)

# Stem
can.rect(cx - 5, cy + 35, 10, 200, fill=CreativeGardenPalette.MINT_CREAM)

# Left leaf (ellipse)
can.ellipse(cx - 40, cy + 120, 30, 15, fill=CreativeGardenPalette.HONEYDEW)

# Right leaf (ellipse)
can.ellipse(cx + 40, cy + 180, 30, 15, fill=CreativeGardenPalette.MINT_CREAM)

# Your turn! Add more petals, change colors, or create your own garden!

can</textarea>
        </div>

        <div class="canvas-container" id="canvas">
            <div style="color: #999;">Your drawing will appear here. Click "Run Code" ‚ñ∂</div>
        </div>
    </div>

    <div class="loading" id="loading">Loading Python... ‚è≥</div>

    <!-- Import Map for CodeMirror 6 -->
    <script type="importmap">
    {
        "imports": {
            "@codemirror/": "https://esm.sh/@codemirror/",
            "@lezer/": "https://esm.sh/@lezer/",
            "codemirror": "https://esm.sh/codemirror@6.0.1"
        }
    }
    </script>

    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
    <script type="module">
        import { EditorView, basicSetup } from "codemirror";
        import { python } from "@codemirror/lang-python";
        import { oneDark } from "@codemirror/theme-one-dark";
        import {
            autocompletion,
            snippetCompletion,
            acceptCompletion,
            completionStatus
        } from "@codemirror/autocomplete";
        import { keymap } from "@codemirror/view";
        import { indentMore } from "@codemirror/commands";

        let pyodide;
        let editor;

        // Make functions and pyodide global for testing
        window.runCode = runCode;
        window.clearCanvas = clearCanvas;

        // Expose pyodide to window for test access (will be set after initialization)
        Object.defineProperty(window, 'pyodide', {
            get() { return pyodide; },
            set(value) { pyodide = value; }
        });

        // ===== SNIPPET-BASED API DEFINITIONS =====
        // Define method snippets with placeholders for better UX
        const API_DEFINITIONS = window.API_DEFINITIONS = (function() {
            const api = {};

            // Canvas methods with snippet completions (users can tab through ${placeholders})
            api['can'] = [
                snippetCompletion("circle(${x}, ${y}, ${radius}, fill=${color})", {
                    label: "circle",
                    type: "method",
                    detail: "(x, y, radius, fill=None, outline=None)",
                    info: "Draw a circle at position (x, y) with given radius"
                }),
                snippetCompletion("rect(${x}, ${y}, ${width}, ${height}, fill=${color})", {
                    label: "rect",
                    type: "method",
                    detail: "(x, y, width, height, fill=None, outline=None)",
                    info: "Draw a rectangle"
                }),
                snippetCompletion("ellipse(${x}, ${y}, ${width}, ${height}, fill=${color})", {
                    label: "ellipse",
                    type: "method",
                    detail: "(x, y, width, height, fill=None, outline=None)",
                    info: "Draw an ellipse"
                }),
                snippetCompletion("line(${x1}, ${y1}, ${x2}, ${y2}, color=${color}, width=${width})", {
                    label: "line",
                    type: "method",
                    detail: "(x1, y1, x2, y2, color=None, width=1)",
                    info: "Draw a line between two points"
                }),
                snippetCompletion("polygon(${points}, fill=${color})", {
                    label: "polygon",
                    type: "method",
                    detail: "(points, fill=None, outline=None)",
                    info: "Draw a polygon from a list of points"
                }),
                snippetCompletion("text(${x}, ${y}, \"${text}\", font_size=${size}, color=${color})", {
                    label: "text",
                    type: "method",
                    detail: "(x, y, text, font_size=12, color=None)",
                    info: "Draw text at position (x, y)"
                }),
                snippetCompletion("rounded_rect(${x}, ${y}, ${width}, ${height}, ${radius}, fill=${color})", {
                    label: "rounded_rect",
                    type: "method",
                    detail: "(x, y, width, height, radius, fill=None, outline=None)",
                    info: "Draw a rectangle with rounded corners"
                }),
                snippetCompletion("grid(spacing=${spacing}, color=\"${color}\", show_coords=${bool})", {
                    label: "grid",
                    type: "method",
                    detail: "(spacing=50, color='#E8E8E8', show_coords=False)",
                    info: "Draw a coordinate grid with optional labels"
                }),
                snippetCompletion("show_palette(${PaletteClass})", {
                    label: "show_palette",
                    type: "method",
                    detail: "(palette_class, columns=4, rect_width=120, rect_height=40, padding=10)",
                    info: "Display all colors from a palette class"
                }),
                { label: "to_svg", type: "method", apply: "to_svg()", detail: "()", info: "Return SVG string representation" },
                { label: "clear", type: "method", apply: "clear()", detail: "()", info: "Clear the canvas" }
            ];

            // Extract palette colors dynamically from embedded Python code
            const shapesCode = `{{ shapes_code }}`;
            let match;

            // Extract Color class constants
            const colorRegex = /class\s+Color:[\s\S]*?(?=\n(?:class|def|\Z))/;
            const colorMatch = shapesCode.match(colorRegex);
            if (colorMatch) {
                const colorCode = colorMatch[0];
                const colorConstRegex = /(\w+)\s*=\s*["']#[0-9A-Fa-f]{6}["']/g;
                const colors = [];
                while ((match = colorConstRegex.exec(colorCode)) !== null) {
                    colors.push({
                        label: match[1],
                        type: "constant",
                        apply: match[1],
                        info: `Color constant`
                    });
                }
                api['Color'] = colors;
            }

            // Extract CreativeGardenPalette constants
            const gardenRegex = /class\s+CreativeGardenPalette:[\s\S]*?(?=\n(?:class|def|\Z))/;
            const gardenMatch = shapesCode.match(gardenRegex);
            if (gardenMatch) {
                const gardenCode = gardenMatch[0];
                const gardenConstRegex = /(\w+)\s*=\s*["']#[0-9A-Fa-f]{6}["']/g;
                const gardenColors = [];
                while ((match = gardenConstRegex.exec(gardenCode)) !== null) {
                    gardenColors.push({
                        label: match[1],
                        type: "constant",
                        apply: match[1],
                        info: `CreativeGardenPalette color`
                    });
                }
                api['CreativeGardenPalette'] = gardenColors;
            }

            // Extract CalmOasisPalette constants
            const oasisRegex = /class\s+CalmOasisPalette:[\s\S]*?(?=\n(?:class|def|\Z))/;
            const oasisMatch = shapesCode.match(oasisRegex);
            if (oasisMatch) {
                const oasisCode = oasisMatch[0];
                const oasisConstRegex = /(\w+)\s*=\s*["']#[0-9A-Fa-f]{6}["']/g;
                const oasisColors = [];
                while ((match = oasisConstRegex.exec(oasisCode)) !== null) {
                    oasisColors.push({
                        label: match[1],
                        type: "constant",
                        apply: match[1],
                        info: `CalmOasisPalette color`
                    });
                }
                api['CalmOasisPalette'] = oasisColors;
            }

            return api;
        })();

        // General keywords (classes) with snippet support
        const generalKeywords = [
            snippetCompletion("Canvas(${width}, ${height})", {
                label: "Canvas",
                type: "class",
                detail: "(width, height)",
                info: "Create a new drawing canvas"
            }),
            {
                label: "Color",
                type: "class",
                apply: "Color.",
                info: "Basic color palette class"
            },
            {
                label: "CreativeGardenPalette",
                type: "class",
                apply: "CreativeGardenPalette.",
                info: "Pastel color palette for creative projects"
            },
            {
                label: "CalmOasisPalette",
                type: "class",
                apply: "CalmOasisPalette.",
                info: "Calming blues and greens color palette"
            }
        ];

        // Smart completion function that detects object.method patterns (CodeMirror 6 API)
        function smartPythonCompletions(context) {
            // Get text before cursor
            let before = context.matchBefore(/\w+\.\w*/);

            // Check if we're typing after a dot (e.g., "can.circle")
            if (before) {
                let text = before.text;
                let dotIndex = text.lastIndexOf('.');

                if (dotIndex > 0) {
                    // Extract object name and partial method
                    let objectName = text.substring(0, dotIndex);
                    let partialMethod = text.substring(dotIndex + 1);

                    // Look up methods for this object
                    if (API_DEFINITIONS[objectName]) {
                        let methods = API_DEFINITIONS[objectName];

                        return {
                            from: before.from + dotIndex + 1,
                            options: methods,
                            validFor: /^\w*$/
                        };
                    }
                }
            }

            // Otherwise, check for regular word completion
            let word = context.matchBefore(/\w*/);
            if (!word || (word.from == word.to && !context.explicit))
                return null;

            return {
                from: word.from,
                options: generalKeywords,
                validFor: /^\w*$/
            };
        }

        // Get initial code from textarea
        const initialCode = document.getElementById('editor').value;

        // Initialize CodeMirror 6 editor
        editor = new EditorView({
            doc: initialCode,
            extensions: [
                basicSetup,
                python(),
                oneDark,

                // Autocompletion with custom source
                autocompletion({
                    override: [smartPythonCompletions],
                    defaultKeymap: true
                }),

                // Tab key: accept completion OR indent
                keymap.of([{
                    key: "Tab",
                    run: (view) => {
                        // If completion is active, accept it
                        if (completionStatus(view.state) === "active") {
                            return acceptCompletion(view);
                        }
                        // Otherwise, indent
                        return indentMore(view);
                    }
                }]),

                EditorView.lineWrapping,

                // Add keyboard shortcuts
                EditorView.domEventHandlers({
                    keydown(event, view) {
                        // Ctrl-Enter or Cmd-Enter to run code
                        if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                            runCode();
                            return true;
                        }
                        return false;
                    }
                })
            ],
            parent: document.querySelector('.editor-container')
        });

        // Hide the textarea since CodeMirror creates its own DOM
        document.getElementById('editor').style.display = 'none';

        // Initialize Pyodide
        async function initPyodide() {
            pyodide = await loadPyodide();

            // Load the shapes library
            await pyodide.runPythonAsync(`
{{ shapes_code }}
        `);

            document.getElementById('loading').style.display = 'none';
            document.getElementById('runBtn').disabled = false;
            document.getElementById('status').textContent = 'Ready! ‚úì';

            // Auto-run code on load
            runCode();
        }

        // Run user code
        async function runCode() {
            // Get code from CodeMirror 6 editor
            const code = editor.state.doc.toString();
            const errorDiv = document.getElementById('error');
            const canvasDiv = document.getElementById('canvas');
            const statusSpan = document.getElementById('status');

            errorDiv.style.display = 'none';
            statusSpan.textContent = 'Running...';

            try {
                // Run the code
                await pyodide.runPythonAsync(code);

                // Get the canvas result
                const result = pyodide.globals.get('can');

                if (result && typeof result.to_svg === 'function') {
                    const svg = result.to_svg();
                    canvasDiv.innerHTML = svg;
                    statusSpan.textContent = 'Success! ‚úì';
                    statusSpan.style.color = '#4CAF50';
                } else {
                    canvasDiv.innerHTML = '<div style="color: #999;">Make sure your code ends with "can" to display the canvas.</div>';
                    statusSpan.textContent = '';
                }
            } catch (err) {
                errorDiv.textContent = '‚ùå Error: ' + err.message;
                errorDiv.style.display = 'block';
                statusSpan.textContent = 'Error';
                statusSpan.style.color = '#f44336';
                console.error(err);
            }
        }

        function clearCanvas() {
            document.getElementById('canvas').innerHTML = '<div style="color: #999;">Canvas cleared. Click "Run Code" to draw.</div>';
            document.getElementById('error').style.display = 'none';
        }

        // Initialize Pyodide (editor is already initialized above)
        initPyodide();
        document.getElementById('runBtn').disabled = true;
    </script>
</body>

</html>